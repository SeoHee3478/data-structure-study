# 6. 연결 리스트 (Linked List) 🔗

## 📌 개념
배열의 단점을 해결하기 위해 **데이터를 메모리에 분산하여 저장**하고, 각 데이터를 **연결(링크)**하는 방식의 자료구조입니다.  

연결 리스트는 **노드(Node)**라는 단위로 구성되며, 각 노드는  
- 📦 **데이터**를 담는 변수  
- 🧭 **다음 노드의 주소**를 저장하는 변수(포인터)  
를 가지고 있습니다.

필요한 만큼 노드를 만들어 데이터를 저장하고, 포인터를 통해 서로 연결합니다.  
첫 번째 노드(Head)의 주소만 알고 있으면 모든 노드에 순차적으로 접근할 수 있습니다.

—

## 🖼 구조 예시
[Head] → [Data: A | Next] → [Data: B | Next] → [Data: C | Next: NULL]
---

## ⚖️ 특징
연결 구조 덕분에 **배열과는 다른 장단점**을 가집니다.

### ✅ 장점
- **동적 크기 조절 가능**  
  배열과 달리 미리 크기를 정할 필요 없이, 빈 메모리 공간 아무 곳에 노드를 생성해 연결할 수 있습니다.
- **삽입/삭제가 용이**  
  배열은 중간에 데이터를 삽입하면 뒤의 모든 요소를 이동시켜야 하지만, 연결 리스트는 포인터만 변경하면 됩니다.

### ❌ 단점
- **랜덤 접근 불가**  
  배열은 시작 주소에서 인덱스만큼 건너뛰면 바로 접근(O(1))이 가능하지만, 연결 리스트는 처음부터 순차적으로 따라가야 하므로 O(n)의 시간 복잡도를 가집니다.
- **추가 메모리 사용**  
  각 노드마다 다음 노드 주소를 저장하는 공간이 필요합니다.

---

## 📊 배열 vs 연결 리스트 비교

| 구분        | 📂 배열(Array)                                 | 🔗 연결 리스트(Linked List) |
|-------------|-----------------------------------------------|-----------------------------|
| 크기        | 고정                                          | 동적                        |
| 메모리 주소 | 연속                                          | 불연속(힙 영역에 동적 할당)  |
| 데이터 참조 | O(1)                                          | O(n)                        |
| 삽입/삭제   | O(n)                                          | O(1) ~ O(n)                  |

---

## 🧐 선택 기준
- **데이터 수가 고정**되고 **참조가 잦은 경우** → **배열**이 유리 (빠른 접근 속도)
- **삽입/삭제가 잦고** 데이터 수가 자주 변하는 경우 → **연결 리스트**가 유리 (동적 크기, 삽입/삭제 용이)

💡 **Tip:** 데이터 양이 많아질수록 선택한 자료구조에 따른 성능 차이가 더욱 커집니다.
