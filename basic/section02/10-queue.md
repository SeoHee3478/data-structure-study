# 큐(Queue)

## 큐란?

- **First In First Out (FIFO)**  
  먼저 들어간 데이터가 먼저 나오는 자료구조
- **스택(Stack)** 과는 반대되는 특성을 가짐
- 실제 예시:  
  - 마트에서 줄 서기  
  - 운영체제의 프로세스 작업 순서 (FIFO 스케줄링)  
  - 맛집 대기줄, 놀이공원 기구 줄 서기 등

---

## 큐의 데이터 삽입과 제거 과정

1. **데이터 삽입**  
   데이터를 순서대로 1, 2, 3, 4 넣는다고 하면,  
   - 데이터는 **큐의 뒤쪽(tail)** 에 삽입

2. **데이터 제거**  
   - 먼저 들어간 데이터가 먼저 나오므로,  
   - 데이터는 **큐의 앞쪽(head)** 에서 제거
   - 즉, 1이 가장 먼저 제거되어야 함

---

## 큐 구현 시 고려사항

- 연결 리스트를 이용해 큐를 구현할 수 있음  
- 하지만, 단방향 연결 리스트로 구현할 경우,  
  - **삭제 작업 시 가장 뒤(마지막) 노드를 접근하기 위해서는 리스트 처음(head)부터 끝까지 순회해야 하므로**  
  - 삭제에 O(n) 시간이 소요되어 비효율적

- 이를 해결하기 위해,  
  - **tail (꼬리) 포인터를 추가하여 마지막 노드를 바로 접근 가능하게 만들고**  
  - 삭제 작업을 O(1) 시간으로 처리할 수 있음

- 또, **이전 노드를 가리키는 포인터가 없는 단방향 연결 리스트에서는 삭제 후 tail을 재설정하기 어려움**  
- 그래서 **이중 연결 리스트(Doubly Linked List)** 로 구조를 변경하면,  
  - 각 노드가 이전 노드를 가리킬 수 있어 tail 관리가 용이

---

## 큐 구현 개선 방향

| 기존 단방향 연결 리스트 | 개선된 이중 연결 리스트 |
|-------------------------|-------------------------|
| 노드가 다음 노드만 가리킴 (단방향) | 노드가 이전 노드와 다음 노드 모두 가리킴 (양방향) |
| tail 재설정이 어려움 | tail 재설정이 쉬워짐 |
| 삭제 시 끝 노드 접근에 O(n) 소요 | tail 변수로 삭제 O(1) 가능 |

---

## 정리

- 큐는 FIFO 구조를 가지며,  
- 데이터 삽입은 tail에서, 제거는 head에서 이루어짐
- 단방향 연결 리스트만으로는 큐 삭제가 비효율적일 수 있어,  
- tail 포인터 추가 및 이중 연결 리스트 활용으로 성능을 개선할 수 있음

---

## 참고

- 큐는 운영체제, 이벤트 처리, 대기열 관리 등 다양한 곳에 널리 사용되는 기본 자료구조
- 효율적인 큐 구현을 위해 자료구조 선택과 포인터 관리가 중요
